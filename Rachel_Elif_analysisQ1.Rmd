
---
title: "Rachel_Elif_analysisQ1.Rmd"
author: "DS421 Team"
date: "April 20, 2020"
output: md_document
---
Install Packages
```{r}
library(tidyverse)
library(foreign)
source('scripts/adams_theme.R') #for ggplot2
```

Import data
```{r}
df <- readRDS('data/cleanDataApril20_v2.Rds')
#this csv describe each ecotype code
eco_type_codes <- read_csv('data/landfire_ecotype_codes.csv')

landfire_codes <- foreign::read.dbf("data/US_200EVT\\US_200EVT.dbf")
landfire_codes <- landfire_codes %>% dplyr::select(VALUE,EVT_PHYS) %>% rename(landfire2016 = VALUE)

n_pixels <- nrow(df) #number of pixels in the dataset 
n_pixels
```


```{r}
#cleaning
df <- df %>%
  left_join(landfire_codes) %>%
  mutate(conifer = case_when(
    (EVT_PHYS == "Conifer" | EVT_PHYS == "Conifer-Hardwood") ~ TRUE,
    TRUE ~ FALSE
  ))
str(df)

###########correcting temp

df$AvGTemp = df$AvGTemp / 12
str(df)
```

exporting fields to make field descriptions
```{r}
#names(df) %>% as.tibble() %>% write_csv(path = "data/data_fields.csv")
```


creating dataframe at the SUID level
```{r}
SUID_df <- df %>%
  mutate_at(.vars = "SUID", .funs = as.factor) %>%
  drop_na(SUID) %>%
  group_by(SUID) %>%
  summarise_if(.predicate = is.numeric, .funs = mean) 
```


```{r}
str(df)
str(SUID_df)
SUID_df$latestSurveyNatDensity
```



```{r}
#looking at distributions...
hist(SUID_df$latestSurveyNatDensity, xlab = "Seedling Density", main = "Histogram of Natural Regeneration Seedling Desnity")


mean(SUID_df$latestSurveyNatDensity)
#151
var(SUID_df$latestSurveyNatDensity)
#118805

#variance >> mean, overdispered

hist(SUID_df$elevation)

plot(SUID_df$AvGppt, SUID_df$latestSurveyNatDensity)

```

```{r}
#pairs at the SUID level
with(SUID_df, pairs(SUID_df[, c('latestSurveyNatDensity', 'burnSev', 'slope', 'elevation', 'CWD', 'SolarLoad')])) #, 'SPB', 'SPO', 'SPMec', 'LAND_SUITA', 'PRODUCTIVI')]))

with(SUID_df, pairs(SUID_df[, c('latestSurveyNatDensity', 'burnSev', 'slope', 'elevation', 'CWD', 'AvGTemp', 'AvGppt')]))

#CWD is a function of temp and precip, correct? so should temp & precip not be included as features in the model as their variation should be captured by CWD??

with(SUID_df, pairs(SUID_df[, c('latestSurveyNatDensity', 'burnSev', 'LAND_SUITA', 'PRODUCTIVI', 'SPB')]))
```


Q1: What variables predict density of naturally regenerating seedlings (in an SUID) within 10 years of a fire? 

To answer this, we want to model latestSurveyNatDensity (in the dataframe SUID_df) as a function of: 
burnSev
slope
elevation
CWD 
SolarLoad
...

For site preparation: SPB, SPO, and SPMec


```{r}
library(gamsel)

#Let's play with fitting a GAM with feature selection
#this package also allows you to do easy (well, hopefully) cross validation
#notes: northness = cos(aspect), eastness = sin(aspect)
#CWD = some function of precip & temp & solar load ?
#I'm including northness, eastness, and CWD as env variables
#I'm NOT inlcuding aspect, temp, precip, solar load 
#We could do this the other way around and include aspect, temp, precip solar load and NOT CWD, northness, eastness, etc. 
#I think otherwise our predictors are strongly colinear with those that they're defined by / they help define
#the SUID_df only includes 360 observations
#can we use all pixels where there's a recorded latestSurveyNatDensity?
#in that case it seems like we DO need to worry about spatial autocorrelation because all pixels within a SUID will have the same recorded natural density of regenerating conifers
#...but this is getting pretty far over my head
filtered_df = df[!is.na(df$latestSurveyNatDensity),]
str(filtered_df)
hist(filtered_df$latestSurveyNatDensity)

```


```{r}
str(filtered_df)
x <- as.matrix(filtered_df %>% dplyr::select(c(burnSev, forestType, SAP_surv_conifers, SAP_burn, elevation, slope, northness, eastness, CWD, AvGppt, AvGTemp, plantedFirst5Years, plantedAfter5Yrs, LAND_SUITA, PRODUCTIVI, SPB, SPO, SPMec)))
y <- as.numeric(filtered_df$latestSurveyNatDensity)

#x_standardized = (x - x_m)/x_std
#standardizing so that gamsel can fit
#scale will do this, scale = F sets col-wise standardization 
x_standardized = scale(x, scale = FALSE)

hist(x_standardized[,5])

#didn't end up needing this:
# dim(x)[1]
# prod(dim(x))
# noise = matrix( rnorm(prod(dim(x)),mean=0,sd=1E-3), dim(x)[1], dim(x)[2]) 
# x_standardized + noise
#dim(x)[2]
#degrees = basis functions. SPO, SPB, SPMech are binary, which is why I'm setting their "degree" to 1
#fit_gamsel <- gamsel(x_standardized, y, num_lambda = 200, degrees=c(1, 1, 10, 10, 10,10,10,10,10, 10, 10, 1,1,1, 1, 1, 1, 1))
#summary(fit_gamsel)



## ?? I don't understand what newx is supposed to be: "nobs_new x p matrix giving values of each predictor at which to plot."
#also don't understand how to interpret plot / summary / printed summary
#plot.gamsel(fit_gamsel, newx = x_standardized)
#print.gamsel(fit_gamsel)

#I would need to spend more time figuring out what's going on under the hood of this package, and I don't think using the pixels checks out, because these aren't independent observations of density but taken from the SUID 

#X = 
#c(burnSev, forestType, SAP_surv_conifers, SAP_burn, elevation, slope, northness, eastness, CWD, AvGppt, AvGTemp, plantedFirst5Years, plantedAfter5Yrs, LAND_SUITA, PRODUCTIVI, SPB, SPO, SPMec)))


fit_gamsel_3<-gamsel(x_standardized, y, num_lambda = 200, degrees=c(1, 1, 10, 10, 10,10,10,10,10, 10, 10, 1,1,1,1, 1, 1, 1))
plot(fit_gamsel, newx = x_standardized)

plot(fit_gamsel_3, newx = x_standardized)
```


```{r}

#LOG TRANSFORM
y_logt <- log(1 + y)
y
y_logt

y_filt = y[y_logt != 0]

y_logt == 0

x_filt = x_standardized[y_logt != 0,]
str(x_filt)

fit_gamsel_filtered<-gamsel(x_filt, y_filt, num_lambda = 200, degrees=c(1, 1, 10, 10, 10,10,10,10,10, 10, 10, 1,1,1,1, 1, 1, 1))


fit_gamsel_logt_filt<-gamsel(x_standardized, y_logt != 0, num_lambda = 200,family="binomial", degrees=c(1, 1, 10, 10, 10,10,10,10,10, 10, 10, 1,1,1,1, 1, 1, 1))


fit_gamsel_logt

sqrt(var(y_filt))


sqrt(var(predict.gamsel(fit_gamsel_logt, x_filt, 200) - y_filt))

hist(y_logt, main = "Histogram of Log-Natural Regeneration Density")

str(y_filt)
str(x_filt)

fit_gamsel_logt<-gamsel(x_standardized, y_logt, num_lambda = 200, degrees=c(1, 1, 10, 10, 10,10,10,10,10, 10, 10, 1,1,1,1, 1, 1, 1))

summary(fit_gamsel_logt)

fit_gamsel_logt

plot(fit_gamsel_logt, newx = x_standardized)

#same general trends,see v4 SAP_burn and v10 AvGppt, but less non-linearity using the log-transformed natregendensity values

#x <- as.matrix(filtered_df %>% dplyr::select(c(burnSev, forestType, SAP_surv_conifers, SAP_burn, elevation, slope, northness, eastness, CWD, AvGppt, AvGTemp, plantedFirst5Years, plantedAfter5Yrs, LAND_SUITA, PRODUCTIVI, SPB, SPO, SPMec)))

#LAND_SUITA negative relationship
#PRODUCTIVI positive relationship --> what goes into these two indices? I'm surprised they have opposite effects
```


```{r}
#cross validation 

#cv_logt_y = cv.gamsel(x_standardized, y_logt, lambda = c(2.0, 1.75, 1.5, 1.25, 1.0, 0.75, 0.5, 0.25, 0.1, 0.05, 0.01, 0.0), degrees=c(1, 1, 10, 10, 10,10,10,10,10, 10, 10, 1,1,1, 1, 1, 1, 1), type.measure = "mse")

cv_logt_y
sd_pred_error_log_multipilicative = exp(sqrt(2.39))
#multiplicative error, usign e^ to get multp. error for nat.density regen measure 
sd_pred_error_log_multipilicative

#sd deviation of the error in predicting the log transformed y
sd_pred_error_log = sqrt(2.39)
sd_log_y = sd(y_logt)


#cv_y= cv.gamsel(x_standardized, y, lambda = c(2.0, 1.75, 1.5, 1.25, 1.0, 0.75, 0.5, 0.25, 0.1, 0.05, 0.01, 0.0), degrees=c(1, 1, 10, 10, 10,10,10,10,10, 10, 10, 1,1,1, 1, 1, 1, 1), type.measure = "mse")

cv_y
sd_pred_error = sqrt(42171)
sd_pred_error

sdy = sd(y)
#root mean sq error you would get if you just predicted a constant (the mean)

#% decrease in pred error as compared to error using mean = 36.6%
((sdy - sd_pred_error) / sdy) *100


```


```{r}

hist(as.numeric(y_logt != 0))

sum(y_logt != 0)/length(y_logt)

hist(y)


sum(y == 0)/length(y)
1.0 - (sum(y_logt != 0)/length(y_logt))


cv_logistic = cv.gamsel(x_standardized, y_logt != 0, family="binomial", lambda = c(2.0, 1.5, 1.0, 0.5, 0.4, 0.3, 0.25, 0.125, 0.0), degrees=c(1, 1, 10, 10, 10,10,10,10,10, 10, 10, 1,1,1, 1, 1, 1, 1), type.measure = "class")

cv_logistic
```


```{r}
library(gam)

#now using SUID_df 
#quasipoisson

fit1_gam <- gam(formula = latestSurveyNatDensity ~ burnSev + slope + elevation + CWD +  northness + eastness, data = SUID_df, family = quasipoisson())
summary(fit1_gam)

fit2_gam <- gam(formula = latestSurveyNatDensity ~ burnSev + forestType + slope + elevation + AvGTemp + AvGppt+ CWD +  northness + eastness + SPB+ SPO + SPMec + plantedFirst5Years + plantedAfter5Yrs, data = SUID_df, family = quasipoisson())
summary(fit2_gam)

anova(fit1_gam, fit2_gam)


SUID_df

fit2.5_gam <- gam(formula = latestSurveyNatDensity ~ burnSev + forestType + slope + aspect + elevation + AvGTemp + AvGppt+ SolarLoad + landfire2016 + CWD + northness + eastness + SPB+ SPO + SPMec + plantedFirst5Years + plantedAfter5Yrs + LAND_SUITA + PRODUCTIVI, data = filtered_df, family = quasipoisson())

summary(fit2.5_gam)
```



```{r}
library(MASS)
#need the MASS package to use negative binomial
#negative biomial bc variance is much larger than mean, see wiki for details: https://en.wikipedia.org/wiki/Negative_binomial_distribution#Poisson_distribution

Fit1_nb <- glm.nb(formula = latestSurveyNatDensity ~ burnSev + forestType +slope + elevation + CWD+ northness + eastness, data = SUID_df)
summary(Fit1_nb)

Fit2_nb <-glm.nb(formula = latestSurveyNatDensity ~ burnSev + forestType +slope + elevation + CWD+ northness + eastness + SPB + SPO + SPMec + plantedFirst5Years + plantedAfter5Yrs, data = SUID_df)
summary(Fit2_nb)
#did not converge

anova(Fit1_nb, Fit2_nb)


#with filtered df: 
#removing LAND_SUITA
#removing planted -- correlated w site potential?


Fit2.5_nb <-glm.nb(formula = latestSurveyNatDensity ~ burnSev + slope + elevation + northness + eastness + AvGppt + AvGTemp + SPB + SPO + SPMec + PRODUCTIVI, data = filtered_df)

summary(Fit2.5_nb)

SUID_df$LAND_SUITA



```


```{r}
#GLM
#environmental + management + FS measures of productivity/suitability
#What does FS use to create suitability & productivity indices?

str(SUID_df)
Fit3 <- lm(formula = latestSurveyNatDensity ~ burnSev + forestType + SAP_surv_conifers + SAP_burn +slope + elevation + CWD+ SolarLoad + LAND_SUITA + PRODUCTIVI, data = SUID_df)
summary(Fit3)

#environmental + FS land suitabiltiy & productivity indices
Fit4 <- lm(formula = latestSurveyNatDensity ~ burnSev + forestType + SAP_surv_conifers + SAP_burn +slope + elevation + CWD+ SolarLoad + LAND_SUITA + PRODUCTIVI + SPB + SPO + SPMec, data = SUID_df)
summary(Fit4)

#productivity most predictive

anova(Fit3, Fit4)



```
No significan difference between models where productivity & suitability indices are included


```{r}
#all env variables
Fit7 <- lm(formula = latestSurveyNatDensity ~ burnSev + forestType + SAP_surv_conifers + SAP_burn + elevation + slope + aspect + northness + eastness + CWD + AvGppt + AvGTemp + SolarLoad, + PRODUCTIVI, data = SUID_df)
summary(Fit7)

Fit8 <- lm(formula = latestSurveyNatDensity ~ burnSev + forestType + SAP_surv_conifers + SAP_burn + elevation + slope + aspect + northness + eastness + CWD + AvGppt + AvGTemp + SolarLoad + PRODUCTIVI+ SPB + SPO + SPMec + plantedAfter5Yrs + plantedFirst5Years, data = SUID_df)
summary(Fit8)

plot(SUID_df$PRODUCTIVI, SUID_df$AvGppt)

```

```{r}
layout(matrix(c(1, 2, 3, 4), 2, 2))
plot(Fit1)
plot(Fit2)
```

```{r}
#fit 8 is a GLM with all vars included
#AIC for variable selection 
?step
Fit9 <- glm(formula = latestSurveyNatDensity ~ burnSev + forestType + SAP_surv_conifers + SAP_burn + elevation + slope + aspect + northness + eastness + CWD + AvGppt + AvGTemp + SolarLoad + PRODUCTIVI+ SPB + SPO + SPMec + plantedAfter5Yrs + plantedFirst5Years, data = filtered_df, family= quasipoisson())

summary(Fit9)



Fit10 <- lm(formula = latestSurveyNatDensity ~ burnSev + forestType + SAP_surv_conifers + SAP_burn + elevation + slope + aspect + northness + eastness + CWD + AvGppt + AvGTemp + SolarLoad + PRODUCTIVI+ SPB + SPO + SPMec + plantedAfter5Yrs + plantedFirst5Years, data = filtered_df)
summary(Fit8)
summary(Fit8)
summary(Fit9)
AICfit <- step(Fit10, trace = 0)
summary(AICfit)


Fit11 <- glm(formula = latestSurveyNatDensity ~  elevation + slope + northness + eastness + AvGppt + AvGTemp + PRODUCTIVI + SPB + SPO + SPMec, data = filtered_df, family= quasipoisson())

summary(Fit11)
```




```{r}
#run xtable on "summary(of your moodel) " --> latex code to make table 
#render latex code online
#screenshot
library(xtable)
xtable(summary(Fit11))
```

